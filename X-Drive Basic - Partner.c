#pragma config(Sensor, in1,    liftPot,        sensorPotentiometer)
#pragma config(Motor,  port2,            ,             tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port3,            ,             tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port4,            ,             tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port5,            ,             tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port6,            ,             tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port8,            ,             tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port9,            ,             tmotorVex393_MC29, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

int JoyClear(int origVal) {
	if (abs(origVal) < 10)
		return 0;
	else
		return origVal;
}

int HeightKeep(int potWant) { //2625 mid
	if (potWant > 0) {
		if (SensorValue[liftPot] < potWant - 80) {
			return 40;
		} else if (SensorValue[liftPot] < potWant - 8) {
			return 10;
		} else if (SensorValue[liftPot] > potWant + 80) {
			return -40;
		} else if (SensorValue[liftPot] > potWant + 8) {
			return -10;
		} else {
			return 0;
		}
	} else {
		return 0;
	}

}


task main()
{



	int RightJoyM; //Main Right Y
	int RightJoyS; //Partner Right Y
	int LeftJoyM;  //Main Left Y
	int LeftJoyS;  //Partner Left Y
	int LiftValue; //Both Lift Towers
	int SetLift; 	 //





	while (1) { //This is an omnidirectional one-joystick arcade style drive w/ bumpers for rotate



		if (vexRT[Btn8UXmtr2] == 1) {SetLift = 3270;}
		if (vexRT[Btn8DXmtr2] == 1) {SetLift = 1820;}
		if (vexRT[Btn8RXmtr2] == 1) {SetLift = -5;}

		RightJoyM = JoyClear(vexRT[Ch2]);
		RightJoyS = JoyClear(vexRT[Ch2Xmtr2]);
		LeftJoyM = JoyClear(vexRT[Ch3]);
		LeftJoyS = JoyClear(vexRT[Ch3Xmtr2]);
		LiftValue = RightJoyS + HeightKeep(SetLift);





		motor[port2] = RightJoyM + vexRT[Btn5U]*75 + vexRT[Btn6U]*-75; //Front Right
		motor[port3]= RightJoyM + vexRT[Btn5U]*-75 + vexRT[Btn6U]*75;	 //Back Right
		motor[port8] = LeftJoyM + vexRT[Btn5U]*-75 + vexRT[Btn6U]*75;	 //Front Left
		motor[port9] = LeftJoyM + vexRT[Btn5U]*75 + vexRT[Btn6U]*-75;	 //Back Left
		motor[port5]= LiftValue; //Lift Right Tower
		motor[port6]= LiftValue; // vexRT[Btn8DXmtr2]*-127; //Lift Left Tower
		motor[port4]= LeftJoyS; // + vexRT[Btn7DXmtr2]*-127; //Conveyor



		wait1Msec(10);

			/*
		if (mode == 1)	{
			motor[port2] = LeftJoyM*0.5 + vexRT[Ch4]*-0.5 + vexRT[Btn5U]*50 + vexRT[Btn6U]*-50; //Front Right
			motor[port3] = LeftJoyM*0.5 + vexRT[Ch4]*0.5 + vexRT[Btn5U]*50 + vexRT[Btn6U]*-50;  //Back Right
			motor[port8] = LeftJoyM*0.5 + vexRT[Ch4]*0.5 + vexRT[Btn5U]*-50 + vexRT[Btn6U]*50;  //Front Left
			motor[port9] = LeftJoyM*0.5 + vexRT[Ch4]*-0.5 + vexRT[Btn5U]*-50 + vexRT[Btn6U]*50; //Back Left
			motor[port5]= vexRT[Btn8U]*127 + vexRT[Btn8D]*-127; //Lift Right Tower
			motor[port6]= vexRT[Btn8U]*127 + vexRT[Btn8D]*-127; //Lift Left Tower
			motor[port4]= vexRT[Btn7U]*127 + vexRT[Btn7D]*-127; //Conveyor

		}
		*/


	}
}
