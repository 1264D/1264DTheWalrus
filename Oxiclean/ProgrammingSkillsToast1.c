#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, in1,    Poten1,         sensorPotentiometer)
#pragma config(Sensor, in2,    Poten2,         sensorPotentiometer)
#pragma config(Sensor, dgtl1,  TwoRemote,      sensorTouch)
#pragma config(Sensor, dgtl2,  ArcadeContol,   sensorTouch)
#pragma config(Sensor, dgtl3,  Robert,         sensorTouch)
#pragma config(Sensor, dgtl4,  ,               sensorTouch)
#pragma config(Sensor, dgtl5,  ,               sensorTouch)
#pragma config(Sensor, dgtl6,  ,               sensorTouch)
#pragma config(Sensor, dgtl7,  LiftLimit,      sensorTouch)
#pragma config(Sensor, dgtl8,  ,               sensorTouch)
#pragma config(Sensor, dgtl9,  ,               sensorTouch)
#pragma config(Sensor, dgtl10, ,               sensorTouch)
#pragma config(Sensor, dgtl11, NearvsFar,      sensorTouch)
#pragma config(Sensor, dgtl12, LeftvsRight,    sensorTouch)
#pragma config(Sensor, I2C_1,  BackLeft,       sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Sensor, I2C_2,  BackRight,      sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Motor,  port1,            ,             tmotorVex393_HBridge, openLoop)
#pragma config(Motor,  port2,           FrontRight,    tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port3,           BackRight,     tmotorVex393_MC29, openLoop, reversed, encoderPort, I2C_2)
#pragma config(Motor,  port4,            ,             tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port5,           Arm1,          tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port6,           Arm2,          tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port7,            ,             tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port8,           FrontLeft,     tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port9,           BackLeft,      tmotorVex393_MC29, openLoop, encoderPort, I2C_1)
#pragma config(Motor,  port10,           ,             tmotorVex393_HBridge, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

// This code is for the VEX cortex platform
#pragma platform(VEX2)

int autonMoveL;
int autonMoveR;
task main(){
	autonMoveL = SensorValue[I2C_1];
	autonMoveR = SensorValue[I2C_2];
	while((SensorValue[I2C_1] - autonMoveL <= 80) && (SensorValue[I2C_2] - autonMoveR >= -80)){//Forward
		motor[BackLeft] = 127;
		motor[BackRight] = 127;
		motor[FrontLeft] = 127;
		motor[FrontRight] = 127;
	}
	autonMoveL = SensorValue[I2C_1];
	autonMoveR = SensorValue[I2C_2];
	while((SensorValue[I2C_1] - autonMoveL >= -700) && (SensorValue[I2C_2] - autonMoveR <= 700)){//Back
		motor[BackLeft] = -127;
		motor[BackRight] = -127;
		motor[FrontLeft] = -127;
		motor[FrontRight] = -127;
	}//Knocks dump down
	motor[BackLeft] = 0;
	motor[BackRight] = 0;
	motor[FrontLeft] = 0;
	motor[FrontRight] = 0;
	wait1Msec(10000);
	while(SensorValue[Poten2] >= 2200){ //Lift Arm
		motor[Arm1] = 127;
		motor[Arm2] = 127;
	}
	motor[Arm1] = 0;//Stop arm
	motor[Arm2] = 0;
	autonMoveL = SensorValue[I2C_1];
	autonMoveR = SensorValue[I2C_2];
	while((SensorValue[I2C_1] - autonMoveL >= -1400) && (SensorValue[I2C_2] - autonMoveR <= 1400)){ //Back up into center wall
		motor[BackLeft] = -127;
		motor[BackRight] = -127;
		motor[FrontLeft] = -127;
		motor[FrontRight] = -127;
	}
	motor[BackLeft] = 0;
	motor[BackRight] = 0;
	motor[FrontLeft] = 0;
	motor[FrontRight] = 0;
		while(SensorValue[LiftLimit] == 0){ //Lift Arm to dump
		motor[Arm1] = 127;
		motor[Arm2] = 127;
	}
	motor[Arm1] = 0;
	motor[Arm2] = 0;
	wait1Msec(250);
	while(SensorValue[Poten2] <= 2300){ //Lower Arm
		motor[Arm1] = -127;
		motor[Arm2] = -127;
	}
	motor[Arm1] = 0;//Stop arm
	motor[Arm2] = 0;
	autonMoveL = SensorValue[I2C_1];
	autonMoveR = SensorValue[I2C_2];
	while((SensorValue[I2C_1] - autonMoveL <= 1400) && (SensorValue[I2C_2] - autonMoveR >= -1400)){ //Repeat
		motor[BackLeft] = 127;
		motor[BackRight] = 127;
		motor[FrontLeft] = 127;
		motor[FrontRight] = 127;
	}
	motor[BackLeft] = 0;
	motor[BackRight] = 0;
	motor[FrontLeft] = 0;
	motor[FrontRight] = 0;
	wait1Msec(10000);
	while(SensorValue[Poten2] >= 2200){ //Lift Arm
		motor[Arm1] = 127;
		motor[Arm2] = 127;
	}
	motor[Arm1] = 0;//Stop arm
	motor[Arm2] = 0;
	autonMoveL = SensorValue[I2C_1];
	autonMoveR = SensorValue[I2C_2];
	while((SensorValue[I2C_1] - autonMoveL >= -1400) && (SensorValue[I2C_2] - autonMoveR <= 1400)){ //Back up into center wall
		motor[BackLeft] = -127;
		motor[BackRight] = -127;
		motor[FrontLeft] = -127;
		motor[FrontRight] = -127;
	}
	motor[BackLeft] = 0;
	motor[BackRight] = 0;
	motor[FrontLeft] = 0;
	motor[FrontRight] = 0;
		while(SensorValue[LiftLimit] == 0){ //Lift Arm to dump
		motor[Arm1] = 127;
		motor[Arm2] = 127;
	}
	motor[Arm1] = 0;
	motor[Arm2] = 0;
	wait1Msec(250);
	while(SensorValue[Poten2] <= 2300){ //Lower Arm
		motor[Arm1] = -127;
		motor[Arm2] = -127;
	}
	motor[Arm1] = 0;//Stop arm
	motor[Arm2] = 0;
	while((SensorValue[I2C_1] - autonMoveL <= 600) && (SensorValue[I2C_2] - autonMoveR >= -600)){ //Repeat
		motor[BackLeft] = 127;
		motor[BackRight] = 127;
		motor[FrontLeft] = 127;
		motor[FrontRight] = 127;
	}
	motor[BackLeft] = 0;
	motor[BackRight] = 0;
	motor[FrontLeft] = 0;
	motor[FrontRight] = 0;
	wait1Msec(10000);
	while(SensorValue[Poten2] >= 2200){ //Lift Arm
		motor[Arm1] = 127;
		motor[Arm2] = 127;
	}
	motor[Arm1] = 0;//Stop arm
	motor[Arm2] = 0;
	autonMoveL = SensorValue[I2C_1];
	autonMoveR = SensorValue[I2C_2];
	while((SensorValue[I2C_1] - autonMoveL >= -1400) && (SensorValue[I2C_2] - autonMoveR <= 1400)){ //Back up into center wall
		motor[BackLeft] = -127;
		motor[BackRight] = -127;
		motor[FrontLeft] = -127;
		motor[FrontRight] = -127;
	}
	motor[BackLeft] = 0;
	motor[BackRight] = 0;
	motor[FrontLeft] = 0;
	motor[FrontRight] = 0;
		while(SensorValue[LiftLimit] == 0){ //Lift Arm to dump
		motor[Arm1] = 127;
		motor[Arm2] = 127;
	}
	motor[Arm1] = 0;
	motor[Arm2] = 0;
	wait1Msec(250);
	while(SensorValue[Poten2] <= 2300){ //Lower Arm
		motor[Arm1] = -127;
		motor[Arm2] = -127;
	}
	motor[Arm1] = 0;//Stop arm
	motor[Arm2] = 0;
	autonMoveL = SensorValue[I2C_1];
	autonMoveR = SensorValue[I2C_2];
	while((SensorValue[I2C_1] - autonMoveL <= 80) && (SensorValue[I2C_2] - autonMoveR >= -80)){//Forward
		motor[BackLeft] = 127;
		motor[BackRight] = 127;
		motor[FrontLeft] = 127;
		motor[FrontRight] = 127;
	}
	autonMoveL = SensorValue[I2C_1];
	autonMoveR = SensorValue[I2C_2];
	while((SensorValue[I2C_1] - autonMoveL >= -400) && (SensorValue[I2C_2] - autonMoveR <= 400)){//Back
		motor[BackLeft] = -127;
		motor[BackRight] = -127;
		motor[FrontLeft] = -127;
		motor[FrontRight] = -127;
	}//Knocks dump down
	motor[BackLeft] = 0;
	motor[BackRight] = 0;
	motor[FrontLeft] = 0;
	motor[FrontRight] = 0;
	wait1Msec(10000);
	while(SensorValue[Poten2] >= 2200){ //Lift Arm
		motor[Arm1] = 127;
		motor[Arm2] = 127;
	}
	motor[Arm1] = 0;//Stop arm
	motor[Arm2] = 0;
	autonMoveL = SensorValue[I2C_1];
	autonMoveR = SensorValue[I2C_2];
	while((SensorValue[I2C_1] - autonMoveL >= -1400) && (SensorValue[I2C_2] - autonMoveR <= 1400)){ //Back up into center wall
		motor[BackLeft] = -127;
		motor[BackRight] = -127;
		motor[FrontLeft] = -127;
		motor[FrontRight] = -127;
	}
	motor[BackLeft] = 0;
	motor[BackRight] = 0;
	motor[FrontLeft] = 0;
	motor[FrontRight] = 0;
		while(SensorValue[LiftLimit] == 0){ //Lift Arm to dump
		motor[Arm1] = 127;
		motor[Arm2] = 127;
	}
	motor[Arm1] = 0;
	motor[Arm2] = 0;
	wait1Msec(250);
	while(SensorValue[Poten2] <= 2300){ //Lower Arm
		motor[Arm1] = -127;
		motor[Arm2] = -127;
	}
	motor[Arm1] = 0;//Stop arm
	motor[Arm2] = 0;
	autonMoveL = SensorValue[I2C_1];
	autonMoveR = SensorValue[I2C_2];
}
