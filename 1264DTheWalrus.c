#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, in1,    Lift,           sensorPotentiometer)
#pragma config(Sensor, I2C_1,  FrontLeft,      sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Sensor, I2C_2,  FrontRight,     sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Sensor, I2C_3,  BackLeft,       sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Sensor, I2C_4,  BackRight,      sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Motor,  port1,            ,             tmotorVex393_HBridge, openLoop)
#pragma config(Motor,  port2,           FrontRight,    tmotorVex393_MC29, openLoop, reversed, encoderPort, I2C_1)
#pragma config(Motor,  port3,           BackRight,     tmotorVex393_MC29, openLoop, reversed, encoderPort, I2C_2)
#pragma config(Motor,  port4,            ,             tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port5,           Lift1,         tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port6,           Lift2,         tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port7,            ,             tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port8,           FrontLeft,     tmotorVex393_MC29, openLoop, encoderPort, I2C_3)
#pragma config(Motor,  port9,           BackLeft,      tmotorVex393_MC29, openLoop, encoderPort, I2C_4)
#pragma config(Motor,  port10,           ,             tmotorVex393_HBridge, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#pragma platform(VEX)

//Competition Control and Duration Settings
#pragma competitionControl(Competition)
#pragma autonomousDuration(20)
#pragma userControlDuration(120)

#include "Vex_Competition_Includes.c"   //Main competition background code...do not modify!
int LiftAngle; //Requested angle
bool AngleToggle;

void AngleLift(){
	if(AngleToggle == 1){
		if((SensorValue[in1] >= LiftAngle - 5) || (SensorValue[in1] <= LiftAngle + 5)) {
			motor[Lift1] = 0;
			motor[Lift2] = 0;
			AngleToggle = false;
		}
		if(SensorValue[in1] <= LiftAngle - 5){
			motor[Lift1] = 0;
			motor[Lift2] = 0;
		}
		if(SensorValue[in1] >= LiftAngle + 5){
			motor[Lift1] = 0;
			motor[Lift2] = 0;
		}
	}
}

void base(){
	motor[FrontLeft] = vexRT[Ch3] + vexRT[Btn5U]*127 + vexRT[Btn6U]*-127;
	motor[FrontRight] = vexRT[Ch2] + vexRT[Btn5U]*-127 + vexRT[Btn6U]*127;
	motor[BackLeft] = vexRT[Ch3] + vexRT[Btn5U]*-127 + vexRT[Btn6U]*127;
	motor[BackRight]= vexRT[Ch2] + vexRT[Btn5U]*127 + vexRT[Btn6U]*-127;
}

void lift(){
	if(AngleToggle == false){
		motor[Lift1]= vexRT[Btn8U]* -127 + vexRT[Btn8D]*127;
		motor[Lift2]= vexRT[Btn8U]*-127 + vexRT[Btn8D]*127;
	}
}

void control(){
	base();
	lift();
}

void pre_auton()
{
	bStopTasksBetweenModes = true;
}

task autonomous()
{
	// .....................................................................................
	// Insert user code here.
	// .....................................................................................

	AutonomousCodePlaceholderForTesting();  // Remove this function call once you have "real" code.
}

task usercontrol()
{
	motor[port1] = 0;
	motor[port2] = 0;
	motor[port3] = 0;
	motor[port4] = 0;
	motor[port5] = 0;
	motor[port6] = 0;
	motor[port7] = 0;
	motor[port8] = 0;
	motor[port9] = 0;
	motor[port10] = 0;
	while (true)
	{
		control();
		AngleLift();
	}
}
